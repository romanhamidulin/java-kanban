# Техническое задание

Пришло время потренироваться и усовершенствовать код трекера задач с помощью списков и хеш-таблиц! В этом спринте вам предстоит поработать над историей просмотров: сделать её неограниченной и избавиться от повторных просмотров в ней. А ещё вы добавите в приложение больше тестов. Поехали!


## Подготавливаем ветку

В этом задании вы откажетесь от привычного процесса разработки в главной ветке. Теперь вы будете выполнять каждую проверочную работу в отдельной ветке.

Для выполнения задания текущего спринта создайте в локальном репозитории ветку с названием `<span class="code-inline__content">sprint_6-solution</span>`.


## 

Вернёмся к трекеру задач! Итак, вам нужно:

* Сделать историю посещений неограниченной по размеру.
* Избавиться от повторных просмотров в истории. Если какую-либо задачу посещали несколько раз, то в истории должен остаться только её последний просмотр. Предыдущий должен быть удалён.

Недостаточно реализовать код таким образом, чтобы программа проходила по всей истории просмотров и только после этого удаляла предыдущий просмотр. Ведь тогда время работы этой программы будет линейно зависеть от длины истории.

Ваша цель — реализовать функциональность так, чтобы время просмотра задачи не зависело от общего количества задач в истории.

### Интерфейс `<span class="code-inline__content">HistoryManager</span>`

В приложении уже есть интерфейс для управления историей просмотров — `<span class="code-inline__content">HistoryManager</span>`. Осталось добавить метод `<span class="code-inline__content">void remove(int id)</span>` для удаления задачи из просмотра и реализовать его в классе `<span class="code-inline__content">InMemoryHistoryManager</span>`. Добавьте вызов метода при удалении задач, чтобы они удалялись также из истории просмотров.

Подсказка: структура интерфейса HistoryManager

Интерфейс `<span class="code-inline__content">HistoryManager</span>` будет иметь следующую структуру.

Скопировать кодJAVA

```
public interface HistoryManager {
    void add(Task task);
    void remove(int id);
    List<Task> getHistory();
} 
```

### Дальнейшая разработка алгоритма со связным списком и `<span class="code-inline__content">HashMap</span>`

Программа должна запоминать порядок вызовов метода `<span class="code-inline__content">add</span>`, ведь именно в этом порядке просмотры будут выстраиваться в истории. Для хранения порядка вызовов удобно использовать список.

Если какая-либо задача просматривалась несколько раз, в истории должен отобразиться только последний просмотр. Предыдущий просмотр должен быть удалён сразу после появления нового — за O(1)**O**(**1**).

Из темы о списках вы узнали, что константное время выполнения операции может гарантировать связный список `<span class="code-inline__content">LinkedList</span>`. Однако эта стандартная реализация в данном случае не подойдёт: удалить элементы из списка можно по индексу или по значению с помощью методов `<span class="code-inline__content">remove</span>`, при этом на поиск удаляемого узла тратится время. Поэтому вам предстоит написать собственную реализацию связного списка с индексом по `<span class="code-inline__content">id</span>` задачи.

Вариант связного списка, который мы предлагаем реализовать, должен удалять элемент из произвольного места за O(1)**O**(**1**) с одним важным условием — программа уже знает нужное место в списке и сама управляет его узлами (в отличие от `<span class="code-inline__content">LinkedList</span>`).

Чтобы выполнить условие, создайте стандартную `<span class="code-inline__content">HashMap</span>`. Её ключом будет `<span class="code-inline__content">id</span>` задачи, просмотр которой требуется удалить, а значением — место просмотра этой задачи в списке, то есть узел связного списка. С помощью номера задачи можно получить соответствующий ему узел связного списка и удалить его.

Чтобы реализовать узел двусвязного списка, вспомните материал урока о `<span class="code-inline__content">LinkedList</span>` из темы о списках.

[]()![](https://pictures.s3.yandex.net/resources/Untitled-177_1705593404.png)

Реализация метода `<span class="code-inline__content">getHistory</span>` должна перекладывать задачи из связного списка в `<span class="code-inline__content">ArrayList</span>` для формирования ответа.

### Подсказки

Подсказка 1

Вы уже знакомы с классом `<span class="code-inline__content">LinkedHashMap</span>`. Он представляет собой очень похожую реализацию контейнера, который сохраняет все полезные свойства `<span class="code-inline__content">LinkedList</span>` и добавляет к ним удобство индексации значений через интерфейс `<span class="code-inline__content">Map</span>`. Предлагаем вам реализовать аналог этого класса самостоятельно.

Подсказка 2

Сначала напишите свою реализацию двусвязного списка задач с методами `<span class="code-inline__content">linkLast</span>` и `<span class="code-inline__content">getTasks</span>`. `<span class="code-inline__content">linkLast</span>` будет добавлять задачу в конец этого списка, а `<span class="code-inline__content">getTasks</span>` — собирать все задачи из него в обычный `<span class="code-inline__content">ArrayList</span>`. Убедитесь, что решение работает. Отдельный класс для списка создавать не нужно — реализуйте его прямо в классе `<span class="code-inline__content">InMemoryHistoryManager</span>`. А вот отдельный класс `<span class="code-inline__content">Node</span>` для узла списка необходимо добавить.

Подсказка 3

Добавьте метод `<span class="code-inline__content">removeNode</span>` в класс `<span class="code-inline__content">InMemoryHistoryManager</span>`. В качестве параметра этот метод должен принимать объект `<span class="code-inline__content">Node</span>` — узел связного списка — и удалять его.

Подсказка 4

Создайте `<span class="code-inline__content">HashMap</span>` — будет достаточно её стандартной реализации. В ключах будут храниться `<span class="code-inline__content">id</span>` задач, а в значениях `<span class="code-inline__content">Node</span>` — узлы связного списка. Изначально `<span class="code-inline__content">HashMap</span>` пустая. Она будет заполняться по мере добавления новых задач. Напишите реализацию метода `<span class="code-inline__content">add(Task task)</span>`. Теперь с помощью `<span class="code-inline__content">HashMap</span>` и метода удаления `<span class="code-inline__content">removeNode</span>` метод `<span class="code-inline__content">add(Task task)</span>` будет быстро удалять задачу из списка, если она там есть, а затем вставлять её в конец двусвязного списка. После добавления задачи не забудьте обновить значение узла в `<span class="code-inline__content">HashMap</span>`.

## Совершенствуем unit-тесты

Поработайте над покрытием классов менеджера тестами. Отдельно протестируйте новую функциональность менеджера истории.

* Скорректируйте предыдущие тесты под изменившийся алгоритм хранения версий задачи.
* Проверьте, что встроенный связный список версий, а также операции добавления и удаления работают корректно.
* Покройте тестами ещё несколько функций менеджера задач, которые вы реализовали в предыдущих спринтах. Отдельно уделите внимание целостности данных:
  * Внутри эпиков не должно оставаться неактуальных `<span class="code-inline__content">id</span>` подзадач.
  * С помощью сеттеров экземпляры задач позволяют изменить любое своё поле, но это может повлиять на данные внутри менеджера. Протестируйте эти кейсы и подумайте над возможными вариантами решения проблемы.

## Дополнительное задание. Реализуем пользовательский сценарий

Если у вас останется время, вы можете выполнить дополнительное задание. Реализуйте в классе `<span class="code-inline__content">Main</span>` опциональный пользовательский сценарий:

1. Создайте две задачи, эпик с тремя подзадачами и эпик без подзадач.
2. Запросите созданные задачи несколько раз в разном порядке.
3. После каждого запроса выведите историю и убедитесь, что в ней нет повторов.
4. Удалите задачу, которая есть в истории, и проверьте, что при печати она не будет выводиться.
5. Удалите эпик с тремя подзадачами и убедитесь, что из истории удалился как сам эпик, так и все его подзадачи.

Обратите внимание, что выполнение этого задания необязательно.

Интересного вам программирования!
